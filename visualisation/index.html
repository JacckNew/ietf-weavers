<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IETF Weavers - Social Network Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 120px);
        }
        
        .sidebar {
            width: 300px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        
        .main-content {
            flex: 1;
            position: relative;
        }
        
        #graph {
            width: 100%;
            height: 100%;
            background: white;
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        
        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .control-group input[type="range"] {
            width: 70%;
            margin-right: 10px;
        }
        
        .control-group span {
            font-weight: bold;
            color: #007cba;
            min-width: 60px;
            display: inline-block;
            font-size: 0.9em;
        }
        
        #refresh-data, #reset-filters {
            transition: background-color 0.2s ease;
        }
        
        #refresh-data:hover {
            background: #005a8a;
        }
        
        #reset-filters:hover {
            background: #5a6268;
        }
        
        #refresh-data:disabled, #reset-filters:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .api-status {
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 12px;
            text-align: center;
        }
        
        .api-available {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .api-unavailable {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .stats h3 {
            margin: 0 0 10px 0;
            color: #495057;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        
        .legend {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
        }
        
        .legend h4 {
            margin: 0 0 10px 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 50%;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            z-index: 1000;
        }
        
        .loading-spinner {
            animation: spin 1s linear infinite;
            font-size: 24px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🧠 IETF Weavers</h1>
        <p>Social and Discursive Dynamics of Internet Standard-making</p>
        <p style="font-size: 0.9em; opacity: 0.8;">Enhanced with Live API Backend & Real-time Filtering</p>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <div id="api-status" class="api-status" style="display: none;">
                <!-- API status will be populated by JavaScript -->
            </div>
            
            <div class="stats" id="stats">
                <h3>Network Statistics</h3>
                <div class="stat-item">
                    <span>Nodes:</span>
                    <span id="node-count">-</span>
                </div>
                <div class="stat-item">
                    <span>Links:</span>
                    <span id="link-count">-</span>
                </div>
                <div class="stat-item">
                    <span>Communities:</span>
                    <span id="community-count">-</span>
                </div>
                <div class="stat-item">
                    <span>Topics:</span>
                    <span id="topic-count">-</span>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="node-size">Node Size:</label>
                    <select id="node-size">
                        <option value="degree_centrality">Degree Centrality</option>
                        <option value="betweenness_centrality">Betweenness Centrality</option>
                        <option value="email_count">Email Count</option>
                        <option value="topic_entropy">Topic Entropy</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="node-color">Node Color:</label>
                    <select id="node-color">
                        <option value="community">Community</option>
                        <option value="mailing_lists_count">Mailing Lists</option>
                        <option value="activity_duration_days">Activity Duration</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="link-strength">Link Strength:</label>
                    <input type="range" id="link-strength" min="0" max="10" value="5">
                </div>
                
                <div class="control-group">
                    <label for="min-degree">Minimum Degree Centrality:</label>
                    <input type="range" id="min-degree" min="0" max="50" value="1">
                    <span id="min-degree-value">0.001</span>
                </div>
                
                <div class="control-group">
                    <label for="min-emails">Minimum Emails:</label>
                    <input type="range" id="min-emails" min="0" max="100" value="0">
                    <span id="min-emails-value">0</span>
                </div>
                
                <div class="control-group">
                    <label for="max-nodes">Max Nodes:</label>
                    <input type="range" id="max-nodes" min="50" max="1000" value="500">
                    <span id="max-nodes-value">500</span>
                </div>
                
                <div class="control-group">
                    <label for="data-source">Data Source:</label>
                    <select id="data-source">
                        <option value="api">Live API (Recommended)</option>
                        <option value="json">Static JSON File</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <button id="refresh-data" style="width: 100%; padding: 10px; background: #007cba; color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 5px;">
                        🔄 Refresh Data
                    </button>
                </div>
                
                <div class="control-group">
                    <button id="reset-filters" style="width: 100%; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        ↺ Reset Filters
                    </button>
                </div>
            </div>
            
            <div class="legend" id="legend">
                <h4>Legend</h4>
                <!-- Legend items will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="main-content">
            <svg id="graph"></svg>
            <div id="loading-overlay" class="loading-overlay">
                <div>
                    <div class="loading-spinner">🔄</div>
                    <div>Loading network data...</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip" style="display: none;"></div>
    
    <script>
        // Global variables
        let data = null;
        let svg, g, node, link, simulation;
        let width, height;
        let colorScale, sizeScale;
        let filterTimeout = null; // For debouncing API calls
        
        // API configuration
        const API_BASE = 'http://localhost:8000';
        let isApiAvailable = false;
        
        // Loading state management
        function showLoading() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }
        
        // Initialize visualization
        async function init() {
            try {
                console.log('Initializing IETF Weavers visualization...');
                
                // Check API availability
                await checkApiAvailability();
                
                // Load data based on selected source
                await loadData();
                
                // Setup SVG
                setupSVG();
                
                // Create visualization
                createVisualization();
                
                // Setup controls
                setupControls();
                
            } catch (error) {
                console.error('Error during initialization:', error);
                showError(error);
            }
        }
        
        async function checkApiAvailability() {
            const statusDiv = document.getElementById('api-status');
            statusDiv.style.display = 'block';
            
            try {
                statusDiv.textContent = '🔍 Checking API...';
                statusDiv.className = 'api-status';
                
                const response = await fetch(`${API_BASE}/api/health`, {
                    method: 'GET',
                    timeout: 5000
                });
                
                if (response.ok) {
                    isApiAvailable = true;
                    console.log('✅ API is available');
                    document.getElementById('data-source').value = 'api';
                    statusDiv.textContent = '✅ API Connected (Live Data)';
                    statusDiv.className = 'api-status api-available';
                } else {
                    throw new Error('API health check failed');
                }
            } catch (error) {
                console.warn('⚠️ API not available, will use JSON fallback:', error.message);
                isApiAvailable = false;
                document.getElementById('data-source').value = 'json';
                statusDiv.textContent = '⚠️ API Offline (Static Data)';
                statusDiv.className = 'api-status api-unavailable';
            }
        }
        
        async function loadData() {
            const dataSource = document.getElementById('data-source').value;
            
            try {
                showLoading();
                
                if (dataSource === 'api' && isApiAvailable) {
                    await loadDataFromAPI();
                } else {
                    await loadDataFromJSON();
                }
                
                console.log('Data loaded successfully:', {
                    nodes: data.nodes?.length || 0,
                    links: data.links?.length || 0,
                    topics: data.topics?.length || 0
                });
                
                updateStats();
                
            } catch (error) {
                console.error('Error loading data:', error);
                
                // Try fallback if API fails
                if (dataSource === 'api') {
                    console.log('Attempting JSON fallback...');
                    try {
                        await loadDataFromJSON();
                        updateStats();
                        return;
                    } catch (fallbackError) {
                        console.error('Fallback also failed:', fallbackError);
                    }
                }
                
                throw error;
            } finally {
                hideLoading();
            }
        }
        
        async function loadDataFromAPI() {
            console.log('Loading data from API...');
            
            // Get filter parameters
            const minEmails = +document.getElementById('min-emails').value;
            const maxNodes = +document.getElementById('max-nodes').value;
            const minDegree = +document.getElementById('min-degree').value / 1000; // Convert to decimal
            
            // Build API query parameters
            const params = new URLSearchParams({
                limit: maxNodes,
                min_emails: minEmails,
                min_degree: minDegree.toFixed(6) // Ensure proper decimal format
            });
            
            console.log('API parameters:', Object.fromEntries(params));
            
            // Load graph data
            const graphResponse = await fetch(`${API_BASE}/api/graph?${params}`);
            if (!graphResponse.ok) {
                throw new Error(`API error: ${graphResponse.status} ${graphResponse.statusText}`);
            }
            
            const graphData = await graphResponse.json();
            
            // Load additional data in parallel
            const [statsResponse, topicsResponse] = await Promise.all([
                fetch(`${API_BASE}/api/stats`),
                fetch(`${API_BASE}/api/topics`)
            ]);
            
            const [stats, topics] = await Promise.all([
                statsResponse.ok ? statsResponse.json() : {},
                topicsResponse.ok ? topicsResponse.json() : []
            ]);
            
            // Combine data in expected format
            data = {
                nodes: graphData.nodes || [],
                links: graphData.links || [],
                topics: topics || [],
                metadata: stats || {}
            };
            
            console.log('✅ Data loaded from API');
        }
        
        async function loadDataFromJSON() {
            console.log('Loading data from JSON file...');
            
            const response = await fetch('data.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            data = await response.json();
            
            // Validate data structure
            if (!data.nodes || !Array.isArray(data.nodes)) {
                throw new Error('Invalid data format: missing or invalid nodes array');
            }
            
            if (!data.links || !Array.isArray(data.links)) {
                console.warn('Warning: missing or invalid links array, using empty array');
                data.links = [];
            }
            
            console.log('✅ Data loaded from JSON');
        }
        
        function showError(error) {
            const errorMsg = `
                <div style="color: red; padding: 20px;">
                    <h3>🚨 Error Loading Data</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p><strong>Solutions:</strong></p>
                    <ul>
                        <li><strong>For API mode:</strong> Make sure the FastAPI server is running on port 8000</li>
                        <li>Run: <code>python -m uvicorn server.api:app --reload --port 8000</code></li>
                        <li><strong>For JSON mode:</strong> Serve via HTTP server (not file://)</li>
                        <li>Run: <code>python serve_visualization.py</code></li>
                        <li>Or run: <code>python -m http.server 8000</code> in visualisation/ directory</li>
                        <li>Check that data.json exists and is valid</li>
                        <li>Try switching data source using the dropdown above</li>
                    </ul>
                </div>
            `;
            document.getElementById('stats').innerHTML = errorMsg;
        }
        
        function updateStats() {
            if (!data) return;
            
            const nodeCount = data.nodes?.length || 0;
            const linkCount = data.links?.length || 0;
            const topicCount = data.topics?.length || 0;
            
            document.getElementById('node-count').textContent = nodeCount;
            document.getElementById('link-count').textContent = linkCount;
            document.getElementById('topic-count').textContent = topicCount;
            
            // Count communities
            const communities = new Set(data.nodes?.map(d => d.community) || []);
            document.getElementById('community-count').textContent = communities.size;
            
            // Update metadata display if available
            if (data.metadata) {
                const statsDiv = document.getElementById('stats');
                
                // Add additional stats if available from API
                if (data.metadata.total_emails) {
                    const existingItems = statsDiv.querySelectorAll('.stat-item');
                    const lastItem = existingItems[existingItems.length - 1];
                    
                    // Only add if not already present
                    if (!document.getElementById('total-emails')) {
                        const totalEmailsDiv = document.createElement('div');
                        totalEmailsDiv.className = 'stat-item';
                        totalEmailsDiv.innerHTML = `
                            <span>Total Emails:</span>
                            <span id="total-emails">${data.metadata.total_emails.toLocaleString()}</span>
                        `;
                        lastItem.insertAdjacentElement('afterend', totalEmailsDiv);
                    } else {
                        document.getElementById('total-emails').textContent = data.metadata.total_emails.toLocaleString();
                    }
                }
            }
        }
        
        function setupSVG() {
            const container = document.querySelector('.main-content');
            width = container.clientWidth;
            height = container.clientHeight;
            
            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // Create main group
            g = svg.append('g');
        }
        
        function createVisualization() {
            if (!data || !data.nodes) return;
            
            // Get filter values from API-enabled controls
            const dataSource = document.getElementById('data-source').value;
            let filteredNodes, filteredLinks;
            
            if (dataSource === 'api' && isApiAvailable) {
                // For API data, the filtering is already done server-side
                filteredNodes = data.nodes;
                filteredLinks = data.links;
            } else {
                // For JSON data, apply client-side filtering with network preservation
                const minDegree = +document.getElementById('min-degree').value / 1000; // Convert to decimal
                const minEmails = +document.getElementById('min-emails').value;
                const maxNodes = +document.getElementById('max-nodes').value;
                
                console.log('Client-side filtering with:', { minDegree, minEmails, maxNodes });
                
                // Step 1: Get core nodes that meet filter criteria
                let coreNodes = data.nodes.filter(d => 
                    (d.degree_centrality || 0) >= minDegree &&
                    (d.email_count || 0) >= minEmails
                );
                
                // Sort by importance and limit core nodes
                coreNodes = coreNodes
                    .sort((a, b) => (b.degree_centrality || 0) - (a.degree_centrality || 0))
                    .slice(0, Math.floor(maxNodes * 0.6)); // Use 60% of limit for core nodes
                
                // Step 2: If no nodes meet criteria, use top nodes by activity
                if (coreNodes.length === 0) {
                    console.log('No nodes meet filter criteria, using top active nodes');
                    coreNodes = data.nodes
                        .sort((a, b) => (b.email_count || 0) - (a.email_count || 0))
                        .slice(0, Math.min(50, maxNodes));
                }
                
                // Step 3: Find connected nodes to preserve network structure
                const coreNodeIds = new Set(coreNodes.map(d => d.id));
                const connectedNodeIds = new Set();
                
                // Find nodes that are connected to core nodes
                data.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    if (coreNodeIds.has(sourceId) && !coreNodeIds.has(targetId)) {
                        connectedNodeIds.add(targetId);
                    }
                    if (coreNodeIds.has(targetId) && !coreNodeIds.has(sourceId)) {
                        connectedNodeIds.add(sourceId);
                    }
                });
                
                // Step 4: Add connected nodes (limited to remaining space)
                const remainingSpace = maxNodes - coreNodes.length;
                const connectedNodes = Array.from(connectedNodeIds)
                    .map(id => data.nodes.find(n => n.id === id))
                    .filter(n => n) // Remove undefined
                    .sort((a, b) => (b.degree_centrality || 0) - (a.degree_centrality || 0))
                    .slice(0, remainingSpace);
                
                // Combine all nodes
                filteredNodes = [...coreNodes, ...connectedNodes];
                
                console.log(`Network preservation: ${coreNodes.length} core + ${connectedNodes.length} connected = ${filteredNodes.length} total`);
                
                // Filter links to only include connections between selected nodes
                const allNodeIds = new Set(filteredNodes.map(d => d.id));
                filteredLinks = data.links.filter(d => {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    return allNodeIds.has(sourceId) && allNodeIds.has(targetId);
                }).map(d => ({
                    source: typeof d.source === 'object' ? d.source.id : d.source,
                    target: typeof d.target === 'object' ? d.target.id : d.target,
                    weight: d.weight || 1,
                    interaction_type: d.interaction_type || 'reply'
                }));
            }
            
            console.log(`Displaying ${filteredNodes.length} nodes and ${filteredLinks.length} links`);
            
            // Clear previous visualization
            g.selectAll('*').remove();
            
            // Create scales
            const nodeSizeAttr = document.getElementById('node-size').value;
            const nodeColorAttr = document.getElementById('node-color').value;
            
            // Ensure we have valid domain for size scale
            const sizeValues = filteredNodes.map(d => d[nodeSizeAttr] || 0);
            const sizeDomain = d3.extent(sizeValues);
            if (sizeDomain[0] === sizeDomain[1]) {
                sizeDomain[1] = sizeDomain[0] + 1; // Avoid same min/max
            }
            
            // Ensure minimum node size is visible
            sizeScale = d3.scaleLinear()
                .domain(sizeDomain)
                .range([8, 25]);  // Increased minimum size from 5 to 8
            
            if (nodeColorAttr === 'community') {
                colorScale = d3.scaleOrdinal(d3.schemeCategory10);
            } else {
                const colorValues = filteredNodes.map(d => d[nodeColorAttr] || 0);
                const colorDomain = d3.extent(colorValues);
                if (colorDomain[0] === colorDomain[1]) {
                    colorDomain[1] = colorDomain[0] + 1; // Avoid same min/max
                }
                colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain(colorDomain);
            }
            
            // Stop any existing simulation
            if (simulation) {
                simulation.stop();
            }
            
            // Create force simulation with fresh data
            simulation = d3.forceSimulation(filteredNodes)
                .force('link', d3.forceLink(filteredLinks)
                    .id(d => d.id)
                    .strength(0.1)
                    .distance(50))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => sizeScale(d[nodeSizeAttr] || 0) + 2));
            
            // Create links first
            link = g.selectAll('.link')
                .data(filteredLinks)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => Math.sqrt(d.weight || 1))
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6);
            
            // Create nodes
            node = g.selectAll('.node')
                .data(filteredNodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => sizeScale(d[nodeSizeAttr] || 0))
                .attr('fill', d => {
                    if (nodeColorAttr === 'community') {
                        return colorScale(d.community);
                    } else {
                        return colorScale(d[nodeColorAttr] || 0);
                    }
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .style('cursor', 'pointer')
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Update simulation tick function
            simulation.on('tick', () => {
                if (link) {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                }
                
                if (node) {
                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                }
            });
            
            // Start simulation
            simulation.alpha(1).restart();
            
            // Update legend
            updateLegend();
        }
        
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            
            tooltip.innerHTML = `
                <strong>${d.name || d.id}</strong><br>
                Email Count: ${d.email_count || 0}<br>
                Mailing Lists: ${d.mailing_lists_count || 0}<br>
                Activity Duration: ${d.activity_duration_days || 0} days<br>
                Degree Centrality: ${(d.degree_centrality || 0).toFixed(6)}<br>
                Betweenness Centrality: ${(d.betweenness_centrality || 0).toFixed(6)}<br>
                Community: ${d.community || 'N/A'}<br>
                Topic: ${d.dominant_topic || 'N/A'}
            `;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        function setupControls() {
            // Add event listeners to visualization controls
            document.getElementById('node-size').addEventListener('change', createVisualization);
            document.getElementById('node-color').addEventListener('change', createVisualization);
            
            // Debounced filter function for API calls
            function debouncedFilter() {
                clearTimeout(filterTimeout);
                filterTimeout = setTimeout(async () => {
                    try {
                        const dataSource = document.getElementById('data-source').value;
                        if (dataSource === 'api' && isApiAvailable) {
                            console.log('Applying API filters...');
                            await loadData();
                            createVisualization();
                        } else {
                            console.log('Applying client-side filters...');
                            createVisualization();
                        }
                    } catch (error) {
                        console.error('Error applying filters:', error);
                    }
                }, 300); // 300ms debounce
            }
            
            // Min degree slider with value display and filtering
            const minDegreeSlider = document.getElementById('min-degree');
            const minDegreeValue = document.getElementById('min-degree-value');
            minDegreeSlider.addEventListener('input', (e) => {
                const value = (+e.target.value / 1000).toFixed(6);
                minDegreeValue.textContent = value;
                debouncedFilter();
            });
            
            // Min emails slider with value display and filtering
            const minEmailsSlider = document.getElementById('min-emails');
            const minEmailsValue = document.getElementById('min-emails-value');
            minEmailsSlider.addEventListener('input', (e) => {
                minEmailsValue.textContent = e.target.value;
                debouncedFilter();
            });
            
            // Max nodes slider with value display and filtering
            const maxNodesSlider = document.getElementById('max-nodes');
            const maxNodesValue = document.getElementById('max-nodes-value');
            maxNodesSlider.addEventListener('input', (e) => {
                maxNodesValue.textContent = e.target.value;
                debouncedFilter();
            });
            
            // Data source selector
            document.getElementById('data-source').addEventListener('change', async (e) => {
                try {
                    await loadData();
                    createVisualization();
                } catch (error) {
                    console.error('Error switching data source:', error);
                    showError(error);
                }
            });
            
            // Refresh data button
            document.getElementById('refresh-data').addEventListener('click', async () => {
                const button = document.getElementById('refresh-data');
                const originalText = button.textContent;
                
                try {
                    button.textContent = '🔄 Loading...';
                    button.disabled = true;
                    
                    await loadData();
                    createVisualization();
                    
                    button.textContent = '✅ Refreshed!';
                    setTimeout(() => {
                        button.textContent = originalText;
                    }, 2000);
                    
                } catch (error) {
                    console.error('Error refreshing data:', error);
                    button.textContent = '❌ Error';
                    setTimeout(() => {
                        button.textContent = originalText;
                    }, 2000);
                    showError(error);
                } finally {
                    button.disabled = false;
                }
            });
            
            // Reset filters button
            document.getElementById('reset-filters').addEventListener('click', async () => {
                // Reset all filter values to defaults
                document.getElementById('min-emails').value = 0;
                document.getElementById('max-nodes').value = 500;
                document.getElementById('min-degree').value = 1;
                
                // Update displayed values
                document.getElementById('min-emails-value').textContent = '0';
                document.getElementById('max-nodes-value').textContent = '500';
                document.getElementById('min-degree-value').textContent = '0.001';
                
                // Apply the reset filters
                debouncedFilter();
            });
            
            // Link strength control
            document.getElementById('link-strength').addEventListener('input', (e) => {
                if (simulation && simulation.force('link')) {
                    const strength = +e.target.value / 100;
                    simulation.force('link').strength(strength);
                    simulation.alpha(0.3).restart();
                }
            });
            
            // Initialize slider value displays
            minDegreeValue.textContent = (+minDegreeSlider.value / 1000).toFixed(6);
            minEmailsValue.textContent = minEmailsSlider.value;
            maxNodesValue.textContent = maxNodesSlider.value;
        }
        
        function updateLegend() {
            const nodeColorAttr = document.getElementById('node-color').value;
            const legend = document.getElementById('legend');
            
            if (nodeColorAttr === 'community' && data.nodes) {
                const communities = [...new Set(data.nodes.map(d => d.community))].sort();
                legend.innerHTML = '<h4>Communities</h4>' + 
                    communities.map(c => 
                        `<div class="legend-item">
                            <div class="legend-color" style="background-color: ${colorScale(c)}"></div>
                            <span>Community ${c}</span>
                        </div>`
                    ).join('');
            } else {
                legend.innerHTML = '<h4>Legend</h4><p>Color represents ' + nodeColorAttr.replace('_', ' ') + '</p>';
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.querySelector('.main-content');
            width = container.clientWidth;
            height = container.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            
            if (simulation) {
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            }
        });
    </script>
</body>
</html>